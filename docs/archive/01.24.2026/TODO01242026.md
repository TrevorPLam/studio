# TASKS.md — v6 Integrated (Production-Hardened + Security Report)

**Primary scope (now):** Agent Sessions, Repository Access, AI Integration, GitHub Integration, Security & Safety Hardening

**First-class NFR pillars:** Security, Resilience, Idempotency, Observability, Safety, Defense-in-Depth

**Operating principles:** Preview-first, PR-only, least-privilege, fail-closed, mobile-retry-safe, hallucination-resistant, kill-switch ready

## 0. Document Control

| Field | Value |
|-------|-------|
| Version | v6 |
| Status | Execution-ready, Production-Hardened, Security-Integrated |
| Owner | Solo Operator |
| Audience | Human + AI agents |
| Source of Truth | This file |
| Update Policy | Append-only; add new sections/IDs; never rewrite history |
| Changelog | v6 adds: PALADIN framework, hidden-Unicode sanitisation, adversarial CI, lockfile-lint, advisory DB integration, idempotency keys, OTel GenAI conventions, kill-switch/degraded mode, chaos testing, GitHub App permission audit |

---

## 1. Best-Practices Checklist Standards (applies to every task)
### 1.1 Task ID + Hierarchy

- Epic: groups tasks by domain (AS/RA/AI/GH/XS/XQ/XP/DP/TEST/OPS)
- Task: executable unit with acceptance criteria
- Checklist items: atomic subtasks [TAG-##]

### 1.2 Definition of Ready (DoR)
A task is Ready only if it includes:

- Context (what/why)
- In-scope / out-of-scope boundaries
- Dependencies (what must exist first)
- Expected file paths
- Connected files (what will call it / be affected)
- Acceptance criteria
- **Verification:** steps (how to prove done)

### 1.3 Definition of Done (DoD)

A task is Done only if:

- Acceptance criteria met
- Tests/verification steps pass (or documented waiver)
- Observability emitted (log + correlation)
- Security constraints enforced (fail closed)
- No secrets in logs
- Hallucination checks pass (for AI-generated operations)

### 1.4 Priority System

- P0: blocks safe operation / MVP backbone
- P1: required for reliable prod usage (elevated: audit, runbooks, rate limits)
- P2: post-MVP hardening / scale

---

## 4. MVP Critical Path (P0, end-to-end)

- [ ] P0 Preview: request → context → model → structured output → diff preview
- [ ] P0 Apply: approve → branch → commit(s) → PR created + linked to session
- [ ] P0 Idempotency: no duplicate preview/PR under retries
- [P0] PALADIN input guard: policy-proxy LLM blocks prompt injection ≥ 95%
- [P0] Hidden-Unicode sanitiser: strips zero-width / bidi chars before ingestion
- [P0] Lockfile-lint CI gate: rejects non-HTTPS, unknown hosts, weak hashes
- [P0] Idempotency-Key: client-side Redis cache guarantees exactly-once PR creation
- [P0] Kill-switch: feature-flag disables all mutative actions globally ≤ 5s
- [P0] OTel GenAI spans: gen_ai.system, gen_ai.request.model, gen_ai.usage.* on every LLM call
- [P0] Path policy: allowlist + do-not-touch enforced (preview + apply)
- [P0] Observability: correlated logs by sessionId + requestId + (if webhook) deliveryId
- [P0] Hallucination detection: verify all paths exist before preview
- [P0] Async webhook processing: 202 response within 10s
- [P0] IP allowlist: restrict webhook endpoint to GitHub IPs

---

## AS — Agent Sessions

### AS-CORE-001 — Server-Side Session Persistence (P0)
**Context:** sessions currently client-local. Must be durable + replayable.
**Dependencies:** DB available (any persistent store).
**Expected Files:**

- `src/lib/agent/session-types.ts`
- src/lib/db/agent-sessions.ts
- src/app/api/sessions/route.ts
- src/app/api/sessions/[id]/route.ts
**Connected Files:**

- `src/app/agents/page.tsx`
- src/app/agents/[id]/page.tsx
**Checklist:**

- [ ] [AS-01] Define schema: session, repo binding, goal, state
- [ ] [AS-02] Implement CRUD store (create/get/list/update)
- [ ] [AS-03] Remove localStorage as source-of-truth (optional cache only)
- [ ] [AS-04] Add API: create session + list sessions + fetch by id
**Code Snippet:**
```typescript
export type AgentSessionState =
| "created" | "planning" | "preview_ready"
| "awaiting_approval" | "applying" | "applied" | "failed";
export type AgentSession = {
id: string;
  userId: string;
  repo: { owner: string; name: string; baseBranch: string };
  headBranch?: string;
  goal: string;
  state: AgentSessionState;
  previewId?: string;
  pr?: { number: number; url: string; head: string; base: string };
  createdAt: string;
  updatedAt: string;
};
```
****Acceptance Criteria:**:**

- Session persists across reload/device
- Session is repo-bound and queryable
**Verification:**
Create session; refresh; fetch same session; verify state unchanged
### AS-CORE-002 — Lifecycle + Step Timeline (P0)
**Dependencies:** AS-CORE-001
**Expected Files:**
- src/lib/agent/session-state.ts
- src/lib/db/agent-steps.ts
- src/app/api/sessions/[id]/steps/route.ts
**Connected Files:**
- src/app/agents/[id]/page.tsx
**Checklist:**
- [ ] [AS-05] Define allowed transitions (fail-closed)
- [ ] [AS-06] Persist steps (started/succeeded/failed)
- [ ] [AS-07] Expose step timeline via API
- [ ] [AS-08] Enforce state machine transitions (reject invalid transitions)
**Code Snippet:**
```typescript
export type AgentStepType = "plan" | "context" | "model" | "diff" | "apply";
export type AgentStep = {
id: string;
sessionId: string;
type: AgentStepType;
status: "started" | "succeeded" | "failed";
startedAt: string;
endedAt?: string;
meta?: Record<string, unknown>;
};
// State machine enforcement
const ALLOWED_TRANSITIONS: Record<AgentSessionState, AgentSessionState[]> = {
created: ["planning", "failed"],
planning: ["preview_ready", "failed"],
preview_ready: ["awaiting_approval", "planning", "failed"],
awaiting_approval: ["applying", "preview_ready", "failed"],
applying: ["applied", "failed"],
applied: [],
failed: ["planning"] // allow retry
};
export function assertTransitionAllowed(from: AgentSessionState, to: AgentSessionState) {
if (!ALLOWED_TRANSITIONS[from]?.includes(to)) {
throw new Error(`Invalid transition: `${}from` → ${to}`);
}
}
**Acceptance Criteria:**
- Every session has a step timeline
- Failures show which step failed
- Invalid state transitions are rejected
**Verification:**
Trigger preview; confirm 4 steps persisted; fail one step; confirm failure recorded
Attempt invalid transition (e.g., created → applying); verify rejection
AS-CTRL-003 — Human Approval Gate (P0)
**Dependencies:** AS-CORE-002, RA-PREV-003, XS-SEC-001
Expected Files
- src/lib/agent/approval.ts
- src/app/api/sessions/[id]/approve/route.ts
- src/app/api/sessions/[id]/reject/route.ts
Connected Files
- src/app/agents/[id]/page.tsx
Checklist
- [ ] [AS-09] Approval endpoint moves preview_ready → awaiting_approval → approved
- [ ] [AS-10] Revision invalidates preview payload and returns to planning/preview_ready
- [ ] [AS-11] Immutable approval record
**Code Snippet:**

```typescript
export type ApprovalDecision = "approved" | "rejected";
export type ApprovalRecord = {
sessionId: string;
decision: ApprovalDecision;
byUserId: string;
at: string;
note?: string;
};
****Acceptance Criteria:**:**
- Apply fails unless approved
- Approval record exists and cannot be edited
**Verification:**
Call apply without approve → 409/403
Approve then apply → allowed
## RA — Repository Access
### RA-READ-001 — Branch + Tree Listing (P0)
**Dependencies:** GH-AUTH-001 (GitHub App tokens)
**Expected Files:**
- src/lib/github-reader.ts
- src/app/api/github/repos/[owner]/[repo]/branches/route.ts
- src/app/api/github/repos/[owner]/[repo]/tree/route.ts
**Connected Files:**
- src/app/repositories/[owner]/[repo]/page.tsx
**Checklist:**
- [ ] [RA-01] Resolve default branch via repos.get
- [ ] [RA-02] List branches (bounded)
- [ ] [RA-03] Fetch tree with recursion limits + pagination strategy
**Code Snippet:**
```typescript
await octokit.repos.get({ owner, repo }); // default_branch
await octokit.git.getTree({ owner, repo, tree_sha: sha, recursive: "true" });
**Acceptance Criteria:**
Tree is browseable and bounded for large repos
**Verification:**
Try a large repo; confirm hard cap triggers safe error
RA-READ-002 — File Reads + Size Caps (P0)
**Dependencies:** RA-READ-001, RA-SAFE-004
Expected Files
- src/lib/github-reader.ts
- src/app/api/github/repos/[owner]/[repo]/contents/route.ts
- src/lib/security/path-policy.ts
Checklist
- [ ] [RA-04] Read file content by path+ref
- [ ] [RA-05] Batch read selected files
- [ ] [RA-06] Enforce max bytes per file and total bytes per request
**Code Snippet:**

```typescript
const res = await octokit.repos.getContent({ owner, repo, path, ref });
// If file: res.data.content is base64
****Acceptance Criteria:**:**
Reads are deterministic + bounded
### RA-PREV-003 — Proposed Change Model + Unified Diffs (P0)
**Dependencies:** RA-READ-002, AI-CORE-001, XS-REL-003
**Expected Files:**
- src/lib/agent/proposed-change.ts
- src/lib/diff/unified.ts
- src/app/api/sessions/[id]/preview/route.ts
- src/lib/db/previews.ts
**Connected Files:**
- src/app/agents/[id]/page.tsx (preview UI)
**Checklist:**
- [ ] [RA-07] Canonical proposed change representation
- [ ] [RA-08] Generate unified diff per file
- [ ] [RA-09] Aggregate stats (files/added/removed)
- [ ] [RA-10] Persist preview payload linked to session
**Code Snippet:**
```typescript
export type ProposedFileChange = {
path: string;
action: "create" | "update" | "delete";
after?: string;   // required for create/update
};
export type PreviewPayload = {
sessionId: string;
plan: string[];
changes: ProposedFileChange[];
diffs: { path: string; unified: string }[];
stats: { files: number; addedChars: number; removedChars: number };
};
**Acceptance Criteria:**
Preview endpoint returns diffs without writing to GitHub
RA-SAFE-004 — Path Policy + Do-Not-Touch (P0)
**Dependencies:** none (must exist before apply)
Expected Files
- src/lib/security/path-policy.ts
Checklist
- [ ] [RA-11] Allowlist prefixes (docs/, .repo/, README.md)
- [ ] [RA-12] Do-not-touch list (package.json, lockfiles, workflows) unless explicit override
- [ ] [RA-13] Enforce at preview AND apply
**Code Snippet:**

```typescript
export const ALLOWED_PREFIXES = ["docs/", ".repo/", "README.md"];
export const FORBIDDEN_PREFIXES = [".github/workflows/", "package.json", "pnpm-lock.yaml"];
export function assertPathAllowed(path: string, overrides?: { allowForbidden?: boolean }) {
if (!overrides?.allowForbidden && FORBIDDEN_PREFIXES.some(p => path === p || path.startsWith(p))) {
throw new Error("Forbidden path");
}
if (!ALLOWED_PREFIXES.some(p => path === p || path.startsWith(p))) {
throw new Error("Path not allowed");
}
}
****Acceptance Criteria:**:**
Forbidden paths cannot be previewed/applied without explicit override
### RA-EXT-005 — Content-Type Filtering + Partial Reads (P1)
**Dependencies:** RA-READ-002
**Expected Files:**
- src/lib/github-reader.ts
- src/ai/context-builder.ts
**Checklist:**
- [ ] [RA-14] Skip binaries by default (images, pdf, etc.)
- [ ] [RA-15] Partial-file context: read relevant slices when file exceeds cap
****Acceptance Criteria:**:**
Context stays within budget without losing critical code
### RA-17 — Tree-sitter AST Chunking (P1)
**Context:**
Line-based chunking splits functions mid-statement; AST chunking keeps logical units intact.
**Expected Files:**
- src/lib/ast/chunker.ts
- src/lib/ast/tree-sitter-wrapper.ts
**Checklist:**
- [RA-17-01] Install tree-sitter + language grammars (TS, JS, PY, Go, Java)
- [RA-17-02] Wrap parser: parse(filePath): SyntaxNode
- [RA-17-03] Extract semantic units: function_definition, class_definition, method_definition
- [RA-17-04] Return {text, startLine, endLine, type, name} per chunk
**Code Snippet:**
```typescript
export function chunkFile(path: string): CodeChunk[] {
const src = readFileSync(path, 'utf-8');
const tree = parser.parse(src);
const chunks: CodeChunk[] = [];
traverse(tree.rootNode, (n) => {
if (n.type === 'function_definition') {
chunks.push({
text: src.slice(n.startIndex, n.endIndex),
startLine: n.startPosition.row,
endLine: n.endPosition.row,
type: n.type,
name: nodeName(n)
});
}
});
return chunks;
}
**Acceptance Criteria:**
No chunk contains partial functions/classes; 100 % of .py/.js/.ts/.go/.java files covered.
RA-18 — Sparse BM25 Vector Field (P1)
Expected Files
- src/lib/ast/sparse-vectorizer.ts
Checklist
- [RA-18-01] Tokenise chunk text (lower-case, split, de-dupe)
- [RA-18-02] Compute term-frequency map term → tf
- [RA-18-03] Return sparse vector format {idx: hash(term) % 1000, value: tf}
**Code Snippet:**

```typescript
export function toSparseVector(text: string): Record<number, number> {
const tokens = text.toLowerCase().split(/\W+/);
const freq: Record<string, number> = {};
for (const t of tokens) freq[t] = (freq[t] || 0) + 1;
const out: Record<number, number> = {};
for (const [t, c] of Object.entries(freq)) {
out[murmur(t) % 1000] = c / tokens.length;
}
return out;
}
****Acceptance Criteria:**:**
Milvus insert succeeds; vector dimension ≤ 1000; identical text yields identical vector.
### RA-19 — Dense UniXcoder Embedding Field (P1)
**Expected Files:**
- src/lib/ast/dense-embedder.ts
**Checklist:**
- [RA-19-01] Load microsoft/unixcoder-base once at startup
- [RA-19-02] Tokenise with 512-token limit
- [RA-19-03] Return 768-float array (CLS token)
**Code Snippet:**
```typescript
const tokenizer = AutoTokenizer.from_pretrained('microsoft/unixcoder-base');
const model = AutoModel.from_pretrained('microsoft/unixcoder-base');
export async function embed(code: string): Promise<number[]> {
const inputs = tokenizer(code, { truncation: true, max_length: 512, return_tensors: 'pt' });
const out = model(**inputs);
return out.last_hidden_state[0][0].tolist(); // [768]
}
**Acceptance Criteria:**
Mean latency ≤ 200 ms per chunk; cosine distance between identical chunks ≈ 0.
RA-20 — RRF Fusion Utility (P1)
Expected Files
- src/lib/search/rrf.ts
Checklist
- [RA-20-01] Accept two ranked lists (id, score)[]
- [RA-20-02] Compute RRF: 1/(60 + rank) for each hit
- [RA-20-03] Sum scores per id, sort descending
**Code Snippet:**

```typescript
export function fuse(l1: RankedItem[], l2: RankedItem[], k = 60): RankedItem[] {
const map = new Map<number, number>();
l1.forEach((h, i) => map.set(h.id, (map.get(h.id) || 0) + 1 / (k + i + 1)));
l2.forEach((h, i) => map.set(h.id, (map.get(h.id) || 0) + 1 / (k + i + 1)));
return [...map.entries()].sort((a, b) => b[1] - a[1]).map(([id, score]) => ({ id, score }));
}
****Acceptance Criteria:**:**
Top-k order changes vs either list alone; deterministic for same input.
### RA-21 — Semantic Search HTTP Endpoint (P1)
**Expected Files:**
- src/app/api/repos/[owner]/[repo]/semantic/route.ts
**Checklist:**
- [RA-21-01] Validate owner, repo, q, k (max 50)
- [RA-21-02] Call hybrid search service
- [RA-21-03] Return {results: [{filePath, startLine, endLine, text, score}]}
**Code Snippet:**
```typescript
export async function POST(req: Request, { params }: { params: { owner: string; repo: string } }) {
const { q, k = 10 } = await req.json();
const chunks = await hybridSearch(params.owner, params.repo, q, k);
return NextResponse.json({ results: chunks });
}
**Acceptance Criteria:**
P99 latency ≤ 500 ms; 200 response with array of chunks.
AI — AI Integration
AI-CORE-001 — Structured Output + Validation (P0)
**Dependencies:** none
Expected Files
- src/ai/agent-prompts.ts
- src/ai/schemas.ts
- src/lib/agent/parse-output.ts
Checklist
- [ ] [AI-01] System prompt defines role + constraints
- [ ] [AI-02] Output schema (plan + changes + confidence level)
- [ ] [AI-03] Strict validation (reject malformed)
**Code Snippet:**

```typescript (zod-style pseudo)
// Use zod or equivalent
export const proposedChangeSchema = z.object({
plan: z.array(z.string()),
confidence: z.number().min(0).max(100), // NEW: confidence scoring
needsReview: z.boolean().optional(),
uncertaintyReason: z.string().optional(),
changes: z.array(z.object({
path: z.string(),
action: z.enum(["create","update","delete"]),
content: z.string().optional()
}))
});
****Acceptance Criteria:**:**
Model output is machine-parseable; invalid output fails closed
Model provides confidence score for every proposal
### AI-CTX-002 — Context Builder + Budgeting (P0)
**Dependencies:** RA-READ-002
**Expected Files:**
- src/ai/context-builder.ts
**Checklist:**
- [ ] [AI-04] Assemble context from README + selected files + summaries
- [ ] [AI-05] Budget by estimated tokens/chars; deterministic drop order
- [ ] [AI-06] Persist context manifest (file list + checksums)
- [ ] [AI-07] Implement priority-based context selection algorithm
**Code Snippet:**
```typescript
export function sha256(text: string) {/* impl */}
export type ContextManifestItem = { path: string; sha256: string; bytes: number };
export type ContextManifest = { sessionId: string; items: ContextManifestItem[] };
// Priority-based context selection
export enum ContextPriority {
ALWAYS = 1,        // README.md
EXPLICIT = 2,      // Files mentioned in goal
SAME_DIR = 3,      // Files in same dir as modified
RECENT = 4,        // Recently modified (git blame)
COMODIFIED = 5,    // Frequently co-modified (git log)
FALLBACK = 6       // Everything else
}
export function selectContextFiles(
allFiles: string[],
budget: number,
modifiedPaths: string[],
goal: string
): string[] {
// Sort by priority, drop lowest until under budget
// Implementation omitted for brevity
}
// Log/Store manifest, NOT full content
**Acceptance Criteria:**
Context is bounded and auditable (manifested)
Deterministic file selection given same inputs
AI-CTRL-003 — Prompt Injection Defense + Command Filtering (P0)
**Dependencies:** XS-SEC-001
Expected Files
- src/lib/security/command-filter.ts
- src/lib/security/prompt-injection.ts
Checklist
- [ ] [AI-08] Only accept explicit commands (regex whitelist) in webhook/comment mode
- [ ] [AI-09] Treat rest of comment as untrusted input
- [ ] [AI-10] Never allow user text to modify system/tool policy
**Code Snippet:**

```typescript
export const ALLOWED_COMMANDS = [/^/review\b/i, /^/refactor\b/i, /^/stop\b/i];
export function extractCommand(text: string) {
const first = text.trim().split("\n")[0];
return ALLOWED_COMMANDS.some(r => r.test(first)) ? first.split(/\s+/)[0].toLowerCase() : null;
}
****Acceptance Criteria:**:**
Comments cannot escalate privileges or exfiltrate secrets
### AI-OPS-004 — Model Versioning + Feedback Loop (P1)
**Expected Files:**
- src/lib/ai/registry.ts
- src/lib/ai/feedback.ts
- src/lib/db/ai-usage.ts
**Checklist:**
- [ ] [AI-11] Record model name/version per session + per step
- [ ] [AI-12] Capture approval/rejection outcomes and manual edits (signals)
- [ ] [AI-13] Optional: response caching for repeated previews (bounded)
****Acceptance Criteria:**:**
You can rollback model choice and see outcomes
### AI-SAFE-005 — Confidence Scoring + Low-Confidence Escalation (P1)
**Dependencies:** AI-CORE-001
**Expected Files:**
- src/ai/confidence.ts
- src/lib/agent/escalation.ts
**Checklist:**
- [ ] [AI-14] Require model to output confidence level (0-100) for each proposal
- [ ] [AI-15] Low-confidence escalation: < 75% confidence → flag for review
- [ ] [AI-16] Multi-answer self-check (SelfCheckGPT pattern): generate 3 variants, detect inconsistencies
- [ ] [AI-17] Grounding verification: validate each file operation against actual repo state
**Code Snippet:**
```typescript
export type ConfidenceAssessment = {
score: number; // 0-100
needsReview: boolean;
reason?: string;
};
export async function assessConfidence(
proposedChanges: ProposedFileChange[],
modelConfidence: number
): Promise<ConfidenceAssessment> {
if (modelConfidence < 75) {
return {
score: modelConfidence,
needsReview: true,
reason: "Model confidence below threshold"
};
}
return { score: modelConfidence, needsReview: false };
}
// Self-consistency check (generate N times, compare)
export async function selfConsistencyCheck(
goal: string,
context: string,
n: number = 3
): Promise<{ consistent: boolean; variance: number }> {
// Generate N proposals, measure variance
// High variance = low confidence
}
**Acceptance Criteria:**
Sessions with confidence < 75% are flagged in UI
Self-inconsistent proposals are rejected or escalated
AI-GUARD-006 — Multi-Layer Guardrail Architecture (P1)
**Dependencies:** AI-SAFE-005, DP-PRIV-001
Expected Files
- src/lib/ai/guardrails/pre-generation.ts
- src/lib/ai/guardrails/post-generation.ts
- src/lib/ai/guardrails/brand-safety.ts
- src/lib/ai/guardrails/reasoning.ts
Checklist
- [ ] [AI-18] Pre-generation guardrails: input validation, PII detection in user messages
- [ ] [AI-19] Post-generation guardrails: output validation before preview creation
- [ ] [AI-20] Brand safety checks: ensure PR body follows templates, no profanity
- [ ] [AI-21] Automated reasoning checks: verify logical consistency of proposed changes
**Code Snippet:**

```typescript
export type GuardrailResult = {
passed: boolean;
violations: string[];
blockers: string[]; // Fatal issues
warnings: string[];  // Non-fatal issues
};
export async function runPreGenerationGuardrails(
goal: string,
context: ContextManifest
): Promise<GuardrailResult> {
const violations = [];
// Check for PII in goal
const piiDetected = detectPII(goal);
if (piiDetected.length > 0) {
violations.push(PII detected: `${}piiDetected.join(", ")`);
}
// Check for prompt injection patterns
const injectionDetected = detectPromptInjection(goal);
if (injectionDetected) {
violations.push("Potential prompt injection detected");
}
return {
passed: violations.length === 0,
violations,
blockers: violations,
warnings: []
};
}
export async function runPostGenerationGuardrails(
changes: ProposedFileChange[]
): Promise<GuardrailResult> {
// Validate logical consistency
// Check for secrets in proposed changes
// Verify all paths are valid
}
****Acceptance Criteria:**:**
Input with PII is rejected or redacted
Output with secrets is blocked
Inconsistent proposals are flagged
### AI-22 — Multi-Hop Retrieval Loop (P1)
**Expected Files:**
- src/lib/agent/multi-hop-retriever.ts
**Checklist:**
- [AI-22-01] Decompose goal → subtasks (LLM)
- [AI-22-02] Per subtask generate 3–5 search queries
- [AI-22-03] Retrieve → feed to LLM → decide “sufficient” or “need more”
- [AI-22-04] Repeat ≤ 3 hops or until satisfied
**Code Snippet:**
```typescript
while (hop < 3 && gaps.length) {
const queries = await generateQueries(gaps);
const chunks = await Promise.all(queries.map(q => hybridSearch(q, 3)));
context.push(...chunks.flat());
gaps = await identifyGaps(context);
hop++;
}
**Acceptance Criteria:**
≥ 90 % of subtasks reach “sufficient” within 3 hops; context tokens ≤ 50 k.
AI-23 — OTel Span per Retrieval Hop (P2)
Expected Files
- src/lib/obs/retrieval-tracer.ts
Checklist
- [AI-23-01] Start span gen_ai.retrieval.hop{N} with gen_ai.system=unixcoder
- [AI-23-02] Set gen_ai.usage.input_tokens, result_count, latency_ms
- [AI-23-03] End span on completion
**Code Snippet:**

```typescript
const span = tracer.startSpan(gen_ai.retrieval.hop`${}hop`);
span.setAttributes({
'gen_ai.system': 'unixcoder',
'gen_ai.request.model': 'microsoft/unixcoder-base',
});
span.setAttribute('gen_ai.usage.input_tokens', tokens);
span.setAttribute('result_count', chunks.length);
span.end();
****Acceptance Criteria:**:**
Trace appears in Jaeger; attributes match OpenTelemetry GenAI semantic conventions.
### AI-24 — Retrieved-Context Session Cache (P2)
**Expected Files:**
- src/lib/agent/context-cache.ts
**Checklist:**
- [AI-24-01] Key by sessionId:chunkHash
- [AI-24-02] TTL 1 h
- [AI-24-03] Skip re-fetch if hit
**Code Snippet:**
```typescript
export async function getCached(chunkHash: string, sessionId: string) {
const key = `${}sessionId`:`${}chunkHash`;
const cached = await redis.get(key);
if (cached) return JSON.parse(cached);
return null;
}
**Acceptance Criteria:**
Cache hit reduces retrieval latency to < 5 ms; no stale chunks returned.
GH — GitHub Integration
GH-AUTH-001 — GitHub App Auth (JWT → Installation Token) (P0)
**Dependencies:** none
Expected Files
- src/lib/github-app.ts
- src/lib/security/secrets.ts
Checklist
- [ ] [GH-01] Generate GitHub App JWT from private key
- [ ] [GH-02] Exchange JWT for installation token (repo-scoped)
- [ ] [GH-03] Cache token; expire 60s early
- [ ] [GH-04] Split reader vs actor permissions (where feasible)
**Code Snippet:**

```typescript
function isStale(expiresAtIso: string) {
const exp = Date.parse(expiresAtIso);
return Date.now() > (exp - 60_000);
}
****Acceptance Criteria:**:**
Short-lived, repo-scoped tokens; never logged
### GH-WRITE-002 — Branch/Commit/PR Writer (P0)
**Dependencies:** GH-AUTH-001, AS-CTRL-003, RA-SAFE-004, XS-REL-003
**Expected Files:**
- src/lib/github-writer.ts
- src/app/api/sessions/[id]/apply/route.ts
**Checklist:**
- [ ] [GH-05] Create head branch from base SHA
- [ ] [GH-06] Apply file operations on head
- [ ] [GH-07] Create PR with session link + attribution + /stop instructions
- [ ] [GH-08] Persist PR linkage on session
**Code Snippet:**
```typescript
await octokit.git.createRef({ owner, repo, ref: refs/heads/`${}head`, sha: baseSha });
await octokit.pulls.create({ owner, repo, head, base, title, body });
**Acceptance Criteria:**
No direct writes to main; always PR
GH-WF-003 — Preview → Apply Orchestrator (P0)
**Dependencies:** RA-PREV-003, GH-WRITE-002
Expected Files
- src/lib/agent/workflow.ts
Checklist
- [ ] [GH-09] Apply requires existing preview
- [ ] [GH-10] Preview invalidated on revision
- [ ] [GH-11] Idempotent apply returns same PR for same derived key
**Acceptance Criteria:**
One session = max one PR
GH-HOOK-004 — Async Webhook Processing (10s Response) (P0)
**Dependencies:** XS-REL-003, XS-RES-002
Expected Files
- src/app/api/github/webhooks/route.ts
- src/lib/queue/webhook-queue.ts
- src/lib/queue/worker.ts
Checklist
- [ ] [GH-12] Verify webhook signature BEFORE enqueueing (fail fast)
- [ ] [GH-13] Return 202 Accepted within 10 seconds (GitHub requirement)
- [ ] [GH-14] Enqueue webhook payload to message queue (Redis/SQS/BullMQ)
- [ ] [GH-15] Background worker processes webhooks asynchronously
- [ ] [GH-16] Monitor queue depth; alert if > 1000 pending
**Code Snippet:**

```typescript
// src/app/api/github/webhooks/route.ts
export async function POST(req: Request) {
const start = Date.now();
const rawBody = await req.text();
const sig = req.headers.get('x-hub-signature-256');
const deliveryId = req.headers.get('x-github-delivery');
// P0: Verify signature BEFORE enqueueing
if (!verifySignature(rawBody, sig, process.env.WEBHOOK_SECRET!)) {
log('webhook.unauthorized', { deliveryId });
return new Response('Unauthorized', { status: 401 });
}
// P0: Enqueue and return 202 within 10s
try {
await webhookQueue.add('process', {
deliveryId,
payload: JSON.parse(rawBody),
receivedAt: new Date().toISOString()
});
const elapsed = Date.now() - start;
log('webhook.accepted', { deliveryId, elapsed });
return new Response('Accepted', { status: 202 });

} catch (err) {
log('webhook.enqueue_failed', { deliveryId, error: err });
return new Response('Internal Error', { status: 500 });
}
}
****Acceptance Criteria:**:**
All webhook responses < 10s
No webhook data loss under load
Queue backlog is monitored
**Verification:**
Send 100 webhooks rapidly; verify all return 202 within 10s
Verify all 100 are processed eventually
### GH-SEC-005 — IP Allowlist for Webhook Endpoint (P0)
**Dependencies:** none (infrastructure layer)
**Expected Files:**
- src/lib/security/ip-allowlist.ts
- src/lib/github-meta.ts
- Infrastructure config (nginx/cloudflare/middleware)
**Checklist:**
- [ ] [GH-17] Fetch GitHub webhook IPs from https://api.github.com/meta
- [ ] [GH-18] Store allowlist in fast-access cache (Redis)
- [ ] [GH-19] Refresh IP list every 1 hour (cron job)
- [ ] [GH-20] Enforce at infrastructure layer (nginx/cloudflare) or middleware
- [ ] [GH-21] Log + alert on non-GitHub IP attempts
**Code Snippet:**
```typescript
// src/lib/github-meta.ts
export async function fetchGitHubWebhookIPs(): Promise<string[]> {
const res = await fetch('https://api.github.com/meta');
const data = await res.json();
return data.hooks; // Returns CIDR blocks like "192.30.252.0/22"
}
// src/lib/security/ip-allowlist.ts
import ipRangeCheck from 'ip-range-check';
export async function isGitHubIP(ip: string): Promise<boolean> {
const allowlist = await redis.get('github:webhook:ips');
if (!allowlist) {
// Fallback: fetch synchronously (with timeout)
const ips = await fetchGitHubWebhookIPs();
await redis.set('github:webhook:ips', JSON.stringify(ips), 'EX', 3600);
return ipRangeCheck(ip, ips);
}
return ipRangeCheck(ip, JSON.parse(allowlist));
}
// Middleware
export async function webhookIPCheck(req: Request) {
const ip = req.headers.get('x-forwarded-for') || req.headers.get('x-real-ip');
if (!ip || !(await isGitHubIP(ip))) {
log('webhook.ip_rejected', { ip });
return new Response('Forbidden', { status: 403 });
}
}
**Acceptance Criteria:**
Non-GitHub IPs are rejected at infrastructure layer
IP list refreshes automatically
Manual webhook testing from non-GitHub IP fails
**Verification:**
Send webhook from non-GitHub IP; verify 403
Verify GitHub meta API polled every hour
Simulate IP list update; verify new IPs accepted
DEP — Dependency & Supply Chain
DEP-SUPPLY-001 — Dependency Change Guardrails (P1)
**Context:** Most real-world repo compromises happen via dependency injection, not source edits. Agent must not silently introduce risky dependencies.
**Dependencies:** RA-PREV-003, AI-GUARD-006
Expected Files
- src/lib/security/dependency-detector.ts
- src/lib/security/lockfile-policy.ts
- src/lib/security/advisory-check.ts
Connected Files
- src/lib/agent/proposed-change.ts
- src/app/api/sessions/[id]/preview/route.ts
Checklist
- [ ] [DEP-01] Detect new dependencies introduced by agent (package.json, requirements.txt, go.mod, Cargo.toml)
- [ ] [DEP-02] Flag lockfile changes separately from source changes (visual indicator in preview)
- [ ] [DEP-03] Require explicit approval checkbox for dependency additions
- [ ] [DEP-04] Compare dependency risk score (GitHub Advisory DB / OSV.dev)
- [ ] [DEP-05] Detect direct vs transitive dependency changes
- [ ] [DEP-06] Block agent from modifying lockfiles unless explicit override in path policy
**Code Snippet:**

```typescript
export type DependencyChange = {
type: 'npm' | 'pip' | 'go' | 'cargo' | 'maven';
action: 'add' | 'remove' | 'update';
name: string;
versionBefore?: string;
versionAfter?: string;
isDirect: boolean;
advisories: Advisory[];
riskScore: number; // 0-100
};
export type Advisory = {
id: string; // GHSA-xxxx or CVE-xxxx
severity: 'low' | 'moderate' | 'high' | 'critical';
summary: string;
url: string;
};
export async function detectDependencyChanges(
changes: ProposedFileChange[]
): Promise<DependencyChange[]> {
const depChanges: DependencyChange[] = [];
for (const change of changes) {
// Detect package.json changes
if (change.path === 'package.json' && change.action === 'update') {
const before = JSON.parse(change.before || '{}');
const after = JSON.parse(change.after || '{}');
  const beforeDeps = { ...before.dependencies, ...before.devDependencies };
  const afterDeps = { ...after.dependencies, ...after.devDependencies };
  
  for (const [name, version] of Object.entries(afterDeps)) {
    if (!beforeDeps[name]) {
      const advisories = await checkAdvisories('npm', name, version as string);
      depChanges.push({
        type: 'npm',
        action: 'add',
        name,
        versionAfter: version as string,
        isDirect: true,
        advisories,
        riskScore: calculateRiskScore(advisories)
      });
    }
  }
}

// Detect lockfile mutations
if (change.path.match(/^(package-lock\.json|yarn\.lock|pnpm-lock\.yaml)$/)) {
  // Parse lockfile diff to detect transitive changes
  // Implementation omitted for brevity
}

}
return depChanges;
}
export function calculateRiskScore(advisories: Advisory[]): number {
if (advisories.length === 0) return 0;
const critical = advisories.filter(a => a.severity === 'critical').length;
const high = advisories.filter(a => a.severity === 'high').length;
return Math.min(100, critical * 40 + high * 20);
}
export async function checkAdvisories(
ecosystem: string,
name: string,
version: string
): Promise<Advisory[]> {
// Query GitHub Advisory DB or OSV.dev
const res = await fetch('https://api.osv.dev/v1/query', {
method: 'POST',
body: JSON.stringify({
package: { ecosystem, name },
version
})
});
const data = await res.json();
return data.vulns?.map((v: any) => ({
id: v.id,
severity: v.severity?.[0]?.type?.toLowerCase() || 'moderate',
summary: v.summary,
url: https://osv.dev/vulnerability/`${}v.id`
})) || [];
}
****Acceptance Criteria:**:**
Dependency additions are visually flagged in preview UI
High-risk dependencies (advisories present) require explicit acknowledgment
Lockfile-only changes are separated from source changes
Agent cannot modify lockfiles unless path policy explicitly allows
**Verification:**
Preview that adds lodash@4.17.20 (known CVE); verify advisory shown
Preview that only changes lockfile; verify separate approval checkbox
Attempt to apply with unapproved dependency; verify rejection
### POL-GOV-001 — Policy Drift Detection (P1)
**Context:** Agent enforces policies at runtime, but nothing checks if policies themselves drift over time. This creates self-modifying governance risk.
**Dependencies:** RA-SAFE-004, AS-CORE-001
**Expected Files:**
- src/lib/security/policy-baseline.ts
- src/lib/security/policy-diff.ts
- src/lib/db/policy-snapshots.ts
**Connected Files:**
- src/lib/security/path-policy.ts
- src/app/api/sessions/[id]/preview/route.ts
**Checklist:**
- [ ] [POL-01] Hash policy files at session start (path-policy.ts, command-filter.ts, etc.)
- [ ] [POL-02] Block agent from modifying policy files unless explicit override + elevated approval
- [ ] [POL-03] Alert if runtime policy ≠ baseline policy (detect drift)
- [ ] [POL-04] Store policy snapshot per session for audit trail
- [ ] [POL-05] Detect policy weakening (e.g., allowlist expansion, forbidden list reduction)
**Code Snippet:**
```typescript
import crypto from 'crypto';
export const POLICY_FILES = [
'src/lib/security/path-policy.ts',
'src/lib/security/command-filter.ts',
'src/ai/agent-prompts.ts',
'.repo/agent-policy.json'
];
export type PolicySnapshot = {
sessionId: string;
timestamp: string;
files: Record<string, string>; // path -> sha256
baseline: string; // sha256 of concatenated hashes
};
export async function capturePolicySnapshot(
sessionId: string
): Promise<PolicySnapshot> {
const files: Record<string, string> = {};
for (const path of POLICY_FILES) {
const content = await readFile(path); // from repo or local
files[path] = sha256(content);
}
const baseline = sha256(Object.values(files).sort().join(':'));
const snapshot = {
sessionId,
timestamp: new Date().toISOString(),
files,
baseline
};
await db.policySnapshots.create(snapshot);
return snapshot;
}
export async function detectPolicyDrift(
currentSnapshot: PolicySnapshot,
baselineSnapshot: PolicySnapshot
): Promise<{ drifted: boolean; changes: string[] }> {
const changes: string[] = [];
for (const [path, hash] of Object.entries(currentSnapshot.files)) {
if (baselineSnapshot.files[path] !== hash) {
changes.push(Policy file modified: `${}path`);
}
}
return {
drifted: changes.length > 0,
changes
};
}
export function assertPolicyNotWeakened(
before: PathPolicy,
after: PathPolicy
): void {
// Detect allowlist expansion
const newAllowed = after.allowed.filter(p => !before.allowed.includes(p));
if (newAllowed.length > 0) {
throw new Error(Policy weakening detected: new allowed paths: `${}newAllowed.join(', ')`);
}
// Detect forbidden list reduction
const removedForbidden = before.forbidden.filter(p => !after.forbidden.includes(p));
if (removedForbidden.length > 0) {
throw new Error(Policy weakening detected: removed forbidden paths: `${}removedForbidden.join(', ')`);
}
}
**Acceptance Criteria:**
Policy snapshot captured at session start
Agent cannot modify policy files without elevated override
Policy drift detected and alerted
Policy weakening (allowlist expansion, forbidden list reduction) triggers alert
**Verification:**
Start session; verify policy snapshot created
Manually modify path-policy.ts; verify drift detected
Attempt agent preview that modifies policy file; verify rejection
Simulate allowlist expansion; verify weakening alert
ISO-SESSION-001 — Session Isolation (P0)
**Context:** LLM caches, memory reuse, or prompt leakage can violate session isolation. Must guarantee no cross-session contamination.
**Dependencies:** AI-CORE-001, AS-CORE-001
Expected Files
- src/ai/session-context.ts
- src/lib/cache/session-cache.ts
Connected Files
- src/ai/context-builder.ts
- src/lib/ai/registry.ts
Checklist
- [ ] [ISO-01] No cross-session prompt/context reuse (explicit session boundary)
- [ ] [ISO-02] Cache keys MUST include sessionId + repo (partition caches)
- [ ] [ISO-03] Explicitly zero memory between sessions (clear context buffers)
- [ ] [ISO-04] Never reference previous session outputs unless explicitly linked
- [ ] [ISO-05] Separate model instances per session (if stateful)
**Code Snippet:**

```typescript
export type SessionContext = {
sessionId: string;
repo: { owner: string; name: string };
isolationBoundary: string; // sha256(sessionId + repo)
messages: Message[];
toolOutputs: Record<string, unknown>;
};
export function createSessionContext(
sessionId: string,
repo: { owner: string; name: string }
): SessionContext {
return {
sessionId,
repo,
isolationBoundary: sha256(`${}sessionId`:`${}repo.owner`/`${}repo.name`),
messages: [],
toolOutputs: {}
};
}
export function getCacheKey(
sessionId: string,
repo: { owner: string; name: string },
operation: string
): string {
// MUST include session + repo to prevent cross-contamination
return session:`${}sessionId`:repo:`${}repo.owner`/`${}repo.name`:op:`${}operation`;
}
export async function clearSessionMemory(sessionId: string): Promise<void> {
// Explicitly clear all session-specific caches
const pattern = session:`${}sessionId`:*;
await redis.del(await redis.keys(pattern));
// Clear in-memory buffers
sessionContexts.delete(sessionId);
log('session.memory_cleared', { sessionId });
}
// Prevent accidental cross-session leakage
export function assertSessionBoundary(
context: SessionContext,
expectedSessionId: string
): void {
if (context.sessionId !== expectedSessionId) {
throw new Error(Session boundary violation: expected `${}expectedSessionId`, got `${}context.sessionId`);
}
}
****Acceptance Criteria:**:**
Each session has isolated context
Cache keys include sessionId + repo
No session can access another session’s data
Memory explicitly cleared on session completion
**Verification:**
Create 2 sessions for same repo; verify context isolation
Verify cache keys include sessionId
Complete session A; verify its caches cleared
Attempt to reference session A data from session B; verify failure
## XS — Security
### XS-SEC-001 — Path Policy + Do-Not-Touch (P0)
**Dependencies:** none (must exist before apply)
**Expected Files:**
- src/lib/security/path-policy.ts
**Checklist:**
- [ ] [XS-01] Allowlist prefixes (docs/, .repo/, README.md)
- [ ] [XS-02] Do-not-touch list (package.json, lockfiles, workflows) unless explicit override
- [ ] [XS-03] Enforce at preview AND apply
**Code Snippet:**
```typescript
export const ALLOWED_PREFIXES = ["docs/", ".repo/", "README.md"];
export const FORBIDDEN_PREFIXES = [".github/workflows/", "package.json", "pnpm-lock.yaml"];
export function assertPathAllowed(path: string, overrides?: { allowForbidden?: boolean }) {
if (!overrides?.allowForbidden && FORBIDDEN_PREFIXES.some(p => path === p || path.startsWith(p))) {
throw new Error("Forbidden path");
}
if (!ALLOWED_PREFIXES.some(p => path === p || path.startsWith(p))) {
throw new Error("Path not allowed");
}
}
**Acceptance Criteria:**
Forbidden paths cannot be previewed/applied without explicit override
XS-SEC-002 — Lockfile Write Block (P0)
Expected Files
- src/lib/security/path-policy.ts (amend)
Checklist
- [XS-SEC-02-01] Add *.lock, package-lock.json, yarn.lock, pnpm-lock.yaml, poetry.lock to FORBIDDEN exact-match list
**Code Snippet:**

```typescript
export const FORBIDDEN_EXACT = [
...FORBIDDEN_EXACT,
'package-lock.json', 'yarn.lock', 'pnpm-lock.yaml', 'poetry.lock'
];
****Acceptance Criteria:**:**
Preview/apply rejected with 403 if chunk targets lockfile; CLI install still allowed.
### XS-SEC-003 — Phantom Guard at Apply (P0)
**Expected Files:**
- src/lib/security/phantom-guard.ts
**Checklist:**
- [XS-SEC-03-01] Query NPM/PyPI API for package creation date & monthly downloads
- [XS-SEC-03-02] Reject if <30 days OR <1 k downloads unless override flag
**Code Snippet:**
```typescript
const pkg = await npm.getPackage(name);
if (daysSince(pkg.created) < 30 || pkg.downloads < 1000) {
throw new ForbiddenPathError('Phantom Guard: risky dependency');
}
**Acceptance Criteria:**
Malicious “slopsquatted” packages rejected; override logged to audit table.
XQ — Testing & Quality
XQ-01 — TDD Agent Core (P1)
Expected Files
- src/lib/agent/tdd-agent.ts
Checklist
- [XQ-01-01] Write pytest file from spec
- [XQ-01-02] Run tests → collect failures
- [XQ-01-03] Generate impl → re-run ≤ 5 loops
- [XQ-01-04] Refactor while keeping green
**Code Snippet:**

```typescript
const pyTest = await exec(pytest `${}testFile` -v);
if (pyTest.stdout.includes('FAILED')) {
for (let i = 0; i < 5 && failed; i++) {
impl = await generateFix(testCode, pyTest.stdout);
await writeFile(implFile, impl);
pyTest = await exec(pytest `${}testFile` -v);
}
}
****Acceptance Criteria:**:**
≥ 95 % features pass within 5 iterations; tests remain green after refactor.
### XQ-02 — TDD Iteration Telemetry (P2)
**Expected Files:**
- src/lib/agent/tdd-metrics.ts
**Checklist:**
- [XQ-02-01] Emit tdd.iteration {count, final_status} metric
- [XQ-02-02] Store in session step metadata
**Code Snippet:**
```typescript
metrics.increment('tdd.iteration', { count: iterations, status: finalStatus });
step.meta.tddIterations = iterations;
**Acceptance Criteria:**
Metric visible in Grafana; value persisted in DB.
XQ-03 — HTTP TDD Endpoint (P2)
Expected Files
- src/app/api/sessions/[id]/tdd/route.ts
Checklist
- [XQ-03-01] Accept {spec, featureName}
- [XQ-03-02] Run TDD agent
- [XQ-03-03] Return {testFile, implFile, iterations, success}
**Code Snippet:**

```typescript
export async function POST(req: Request, { params }: { params: { id: string } }) {
const { spec, featureName } = await req.json();
const result = await tddAgent.implement(spec, featureName);
return NextResponse.json(result);
}
****Acceptance Criteria:**:**
200 on success, 422 if >5 iterations, files written to repo.
## TEST — Security & Chaos Testing
### TEST-001 — Security & Chaos Tests in CI (P2)
**Expected Files:**
- .github/workflows/security-chaos.yml
**Checklist:**
- [TEST-001-01] Job runs cybozu/prompt-hardener (block rate ≥ 95 %)
- [TEST-001-02] Job runs Toxiproxy chaos: GitHub API 500 errors, 2 s latency
- [TEST-001-03] CI fails on any security or resilience regression
****Acceptance Criteria:**:**
Pipeline red when prompt injection success > 5 % or outage simulation causes unrecoverable error.
### TEST-002 — Chaos Testing for External Dependencies (P2)
**Expected Files:**
- tests/chaos/github-outage.test.ts
- tests/chaos/llm-timeout.test.ts
**Checklist:**
- [TEST-002-01] Simulate 50 % packet loss to api.github.com
- [TEST-002-02] Simulate OpenAI 429 rate-limit storm
- [TEST-002-03] Assert graceful degradation & recovery
****Acceptance Criteria:**:**
Agent queues work, retries with exponential backoff, and resumes without duplicate actions.
## OPS — Operations & Kill Switch
### OPS-001 — Centralised Kill-Switch & Degraded Mode (P1)
**Expected Files:**
- src/lib/ops/killswitch.ts
- src/app/api/admin/killswitch/route.ts
**Checklist:**
- [OPS-001-01] Feature flag agent.kill-switch (Redis)
- [OPS-001-02] Degraded mode flag agent.read-only
- [OPS-001-03] Reject mutative API calls when either flag active
**Code Snippet:**
```typescript
export function assertNotKilled() {
if (await redis.get('agent.kill-switch')) {
throw new KillSwitchActiveError();
}
}
**Acceptance Criteria:**
Drill: flip flag → all apply endpoints return 503 within 5 s; read-only endpoints still 200.
OBS — Observability
OBS-001 — OpenTelemetry GenAI Semantic Conventions (P1)
Expected Files
- src/lib/obs/otel-genai.ts
Checklist
- [OBS-001-01] Root span gen_ai.agent.session
- [OBS-001-02] LLM span attributes: gen_ai.system, gen_ai.request.model, gen_ai.usage.input_tokens, gen_ai.usage.output_tokens
- [OBS-001-03] Tool span attributes: gen_ai.tool.name, gen_ai.tool.result
**Code Snippet:**

```typescript
const span = tracer.startSpan('gen_ai.llm.chat');
span.setAttributes({
'gen_ai.system': 'openai',
'gen_ai.request.model': 'gpt-4-turbo',
'gen_ai.usage.input_tokens': tokens.prompt,
'gen_ai.usage.output_tokens': tokens.completion
});
****Acceptance Criteria:**:**
Traces validated by Jaeger show full parent-child hierarchy; attributes present on 100 % of spans.
### OBS-002 — Real-Time Cost & Anomaly Dashboard (P2)
**Expected Files:**
- grafana/dashboards/agent-cost.json
- alerts/agent-cost.yml
**Checklist:**
- [OBS-002-01] OTel metric agent.cost.usd per session
- [OBS-002-02] Alert if > $10 in 1 h or > $50 in 24 h
- [OBS-002-03] Slack webhook for alerts
****Acceptance Criteria:**:**
Synthetic test burns $11 in 30 min → alert fires and appears in Slack #alerts.
GH-GITHUB-APP — GitHub App Hardening
### GITHUB-APP-001 — Token Scope Audit & IP Allow-list (P2)
**Expected Files:**
- scripts/audit-app-permissions.ts
- src/lib/github/ip-allowlist.ts
**Checklist:**
- [GITHUB-APP-001-01] Monthly script diffs current vs baseline permissions
- [GITHUB-APP-001-02] Alert on drift
- [GITHUB-APP-001-03] GitHub App settings updated with agent egress IPs only
****Acceptance Criteria:**:**
Script exits 1 if any extra permission detected; IP allow-list contains only /32 of production NAT.

Below are only the newly extracted, fully-expanded TASKS.md entries that appeared in the very last report you sent (the comprehensive 2026 security & reliability deep-dive).
Each block is ready to paste into the master file.
### AI-SAFETY-001 — PALADIN Defense-in-Depth Framework (P0)
**Context:**
### CVE-2025-53773 (CVSS 9.6) proved single-layer prompt-injection filters are insufficient. PALADIN provides five independent layers: input sanitization, system-prompt hardening, tool-authorisation, output filtering, and behavioural monitoring.
**Expected Files:**
- src/lib/security/paladin/input-guard.ts
- src/lib/security/paladin/policy-proxy-llm.ts
- src/lib/security/paladin/tool-authz.ts
- src/lib/security/paladin/output-filter.ts
- src/lib/security/paladin/behaviour-monitor.ts
**Connected Files:**
- src/lib/agent/executor.ts (calls tool-authz)
- src/lib/llm/llm-router.ts (routes through policy-proxy)
**Checklist:**
- [AI-SAFETY-001-01] Deploy policy-proxy LLM (≤ 3 B params) with prompt-injection classifier
- [AI-SAFETY-001-02] Block on classifier score > 0.8; log to audit table
- [AI-SAFETY-001-03] Enforce per-tool RBAC: read|write|admin scopes
- [AI-SAFETY-001-04] Strip secrets from LLM output before user/tool exposure
- [AI-SAFETY-001-05] Emit anomaly metric if tool call pattern deviates > 2 σ from baseline
**Code Snippet:**
```typescript
export async function policyProxyGuard(text: string): Promise<{
safe: boolean; score: number; reason?: string }> {
const res = await classifierModel.predict(text);
return { safe: res.score < 0.8, score: res.score, reason: res.label };
}
**Acceptance Criteria:**
- ≥ 95 % block rate on adversarial test suite (see AI-SAFETY-003)
- Zero regression on benign prompt throughput
**Verification:**
Run pnpm test paladin → expect 100 % pass on 200 injection payloads from cybozu/prompt-hardener dataset.
AI-SAFETY-002 — Hidden-Unicode Sanitization (P0)
Context
Invisible Unicode (zero-width space, bidi-markers) can hide malicious instructions from human reviewers while still being parsed by the LLM.
Expected Files
- src/lib/security/sanitise.ts
Checklist
- [AI-SAFETY-002-01] Allow-list printable ASCII, tabs, newlines; reject all C0/C1 control codes
- [AI-SAFETY-002-02] Normalise NFC before filtering
- [AI-SAFETY-002-03] Flag (do not block) non-Latin scripts for audit
**Code Snippet:**

```typescript
const ALLOWED = /^[\x20-\x7E\t\n\r]+$/;
export function sanitise(input: string): { clean: string; rejected: string[] } {
const rejected: string[] = [];
const clean = [...input].filter(ch => {
if (ALLOWED.test(ch)) return true;
rejected.push(unicodeName(ch));
return false;
}).join('');
return { clean, rejected };
}
****Acceptance Criteria:**:**
- Payload "delete\u200bFiles()" becomes "deleteFiles()"
- Emoji, accented chars, CJK pass through flag-only
**Verification:**
Unit test feeds 50 OWASP-hidden-unicode samples; zero bypasses allowed.
### AI-SAFETY-003 — Automated Adversarial Testing in CI (P0)
**Expected Files:**
- tests/security/adversarial.test.ts
- .github/workflows/adversarial.yml
**Checklist:**
- [AI-SAFETY-003-01] Integrate cybozu/prompt-hardener CLI in CI
- [AI-SAFETY-003-02] Fail build if block-rate < 95 %
- [AI-SAFETY-003-03] Upload HTML report as artifact
**Code Snippet:**
```typescript
- name: Adversarial test
run: |
npx prompt-hardener test 
--model http://localhost:11434/policy-proxy 
--payloads tests/fixtures/payloads.json 
--threshold 0.95
**Acceptance Criteria:**
CI job must pass before merge to main.
SUPPLY-CHAIN-001 — Dependency Mutation Policy (P1)
Expected Files
- .lockfile-lint.yml
- src/lib/security/lockfile-gate.ts
Checklist
- [SUPPLY-CHAIN-001-01] Host allow-list: npm, yarn, pypi.org, files.pythonhosted.org
- [SUPPLY-CHAIN-001-02] Enforce HTTPS only
- [SUPPLY-CHAIN-001-03] Reject unknown hash algorithms
**Code Snippet:**

```typescript
const policy = {
hosts: ['registry.npmjs.org', 'pypi.org'],
schemes: ['https'],
algorithms: ['sha512']
};
export function gate(lockfilePath: string) {
return lockfileLint(lockfilePath, policy);
}
****Acceptance Criteria:**:**
CI fails on policy violation; zero false positives on existing lockfiles.
### SUPPLY-CHAIN-002 — GitHub Advisory DB Integration (P1)
**Expected Files:**
- src/lib/security/advisory-check.ts
**Checklist:**
- [SUPPLY-CHAIN-002-01] Query https://api.github.com/advisories for each new dependency
- [SUPPLY-CHAIN-002-02] Inject summary into PR body
- [SUPPLY-CHAIN-002-03] Block merge if high/critical CVE and no override
**Code Snippet:**
```typescript
const advisories = await getAdvisories(pkgName, version);
if (advisories.some(a => a.severity === 'critical')) {
prBody += \n🚨 **CRITICAL** CVE-`${}a.id` – upgrade to `${}a.patched_version`;
}
**Acceptance Criteria:**
Human reviewer sees coloured warning in PR; override checkbox logged.
SUPPLY-CHAIN-003 — Mandatory Security Review for Lockfiles (P1)
Expected Files
- CODEOWNERS
- .github/lockfile-review.yml
Checklist
- [SUPPLY-CHAIN-003-01] Assign *.lock, package-lock.json, poetry.lock to @security-team
- [SUPPLY-CHAIN-003-02] Branch protection requires CODEOWNER approval
**Acceptance Criteria:**
No lockfile PR can merge without security-team ✅.
IDEMPOTENCY-001 — Idempotency-Key Pattern for PR Creation (P1)
Expected Files
- src/lib/github/idempotency.ts
- src/lib/redis/idempotency-store.ts
Checklist
- [IDEMPOTENCY-001-01] Key = sha256(owner+repo+action+headBranch+sha)
- [IDEMPOTENCY-001-02] TTL 24 h
- [IDEMPOTENCY-001-03] Return cached PR URL on duplicate
**Code Snippet:**

```typescript
export async function createPrIdempotent(req: CreatePrRequest) {
const key = create-pr:`${}req.owner`/`${}req.repo`/`${}req.headBranch`/`${}req.sha`;
const cached = await redis.get(key);
if (cached) return JSON.parse(cached);
const pr = await octokit.pulls.create(req);
await redis.setex(key, 86400, JSON.stringify(pr));
return pr;
}
****Acceptance Criteria:**:**
Webhook replay test shows 1 PR created, 2nd returns same URL.
### IDEMPOTENCY-002 — Per-Repo/Per-PR Distributed Lock (P1)
**Expected Files:**
- src/lib/redis/redlock.ts
**Checklist:**
- [IDEMPOTENCY-002-01] Lock key lock:repo:{id}:branch:{name}
- [IDEMPOTENCY-002-02] Lease 5 min with 10 s auto-extend while active
- [IDEMPOTENCY-002-03] Use Lua script to release only if token matches
**Code Snippet:**
```typescript (Lua)
local key, token = KEYS[1], ARGV[1]
if redis.call("get", key) == token then
return redis.call("del", key)
else
return 0
end
**Acceptance Criteria:**
Concurrent webhook deliveries on same branch serialise without duplicate commits.
IDEMPOTENCY-003 — Webhook Deduplication (P1)
Expected Files
- src/app/api/github/webhooks/idempotency-middleware.ts
Checklist
- [IDEMPOTENCY-003-01] Include X-GitHub-Delivery UUID in idempotency key
- [IDEMPOTENCY-003-02] 409 Conflict response on duplicate within TTL
**Acceptance Criteria:**
Replay of same delivery ID returns 409 within 5 min window.
OBS-001 — OpenTelemetry GenAI Semantic Conventions (P1)
Expected Files
- src/lib/obs/otel-genai.ts
Checklist
- [OBS-001-01] Root span gen_ai.agent.session
- [OBS-001-02] LLM span attributes: gen_ai.system, gen_ai.request.model, gen_ai.usage.input_tokens, gen_ai.usage.output_tokens
- [OBS-001-03] Tool span attributes: gen_ai.tool.name, gen_ai.tool.result
**Code Snippet:**

```typescript
const span = tracer.startSpan('gen_ai.llm.chat');
span.setAttributes({
'gen_ai.system': 'openai',
'gen_ai.request.model': 'gpt-4-turbo',
'gen_ai.usage.input_tokens': tokens.prompt,
'gen_ai.usage.output_tokens': tokens.completion
});
****Acceptance Criteria:**:**
Traces validated by Jaeger show full parent-child hierarchy; attributes present on 100 % of spans.
### OBS-002 — Real-Time Cost & Anomaly Dashboard (P2)
**Expected Files:**
- grafana/dashboards/agent-cost.json
- alerts/agent-cost.yml
**Checklist:**
- [OBS-002-01] OTel metric agent.cost.usd per session
- [OBS-002-02] Alert if > $10 in 1 h or > $50 in 24 h
- [OBS-002-03] Slack webhook for alerts
****Acceptance Criteria:**:**
Synthetic test burns $11 in 30 min → alert fires and appears in Slack #alerts.
### TEST-001 — Security & Chaos Tests in CI (P2)
**Expected Files:**
- .github/workflows/security-chaos.yml
**Checklist:**
- [TEST-001-01] Job runs cybozu/prompt-hardener (block rate ≥ 95 %)
- [TEST-001-02] Job runs Toxiproxy chaos: GitHub API 500 errors, 2 s latency
- [TEST-001-03] CI fails on any security or resilience regression
****Acceptance Criteria:**:**
Pipeline red when prompt injection success > 5 % or outage simulation causes unrecoverable error.
### TEST-002 — Chaos Testing for External Dependencies (P2)
**Expected Files:**
- tests/chaos/github-outage.test.ts
- tests/chaos/llm-timeout.test.ts
**Checklist:**
- [TEST-002-01] Simulate 50 % packet loss to api.github.com
- [TEST-002-02] Simulate OpenAI 429 rate-limit storm
- [TEST-002-03] Assert graceful degradation & recovery
****Acceptance Criteria:**:**
Agent queues work, retries with exponential backoff, and resumes without duplicate actions.
### GITHUB-APP-001 — Token Scope Audit & IP Allow-list (P2)
**Expected Files:**
- scripts/audit-app-permissions.ts
- src/lib/github/ip-allowlist.ts
**Checklist:**
- [GITHUB-APP-001-01] Monthly script diffs current vs baseline permissions
- [GITHUB-APP-001-02] Alert on drift
- [GITHUB-APP-001-03] GitHub App settings updated with agent egress IPs only
****Acceptance Criteria:**:**
Script exits 1 if any extra permission detected; IP allow-list contains only /32 of production NAT.
